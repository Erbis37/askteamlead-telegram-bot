import os
import re
import uuid
import datetime
import pytz
from icalendar import Calendar, Event, vDatetime
import logging
import traceback
from io import BytesIO
from typing import Dict, Optional, List, Tuple, Any
import json
import random
import string
from claude_utils import get_claude_completion


def ensure_valid_calendar_filename(filename: str, event_details: Dict, platform: str) -> str:
    """
    Ensures the calendar filename uses the current date and has a unique hash.
    Fixes common issues with filenames returned from Claude.
    
    Args:
        filename: Original filename generated by Claude
        event_details: Event details dictionary containing date/time information
        platform: Platform type (ios, android, outlook)
        
    Returns:
        Corrected filename with proper date and hash
    """
    import datetime
    import re
    import random
    import string
    
    # Generate a current date-based timestamp
    now = datetime.datetime.now()
    
    # Try to extract event date/time from event details
    event_date = now
    try:
        # Use event start_time if available
        start_time = event_details.get('start_time')
        if start_time:
            # Try different date formats
            for fmt in ["%Y-%m-%d %H:%M", "%d.%m.%Y %H:%M", "%m/%d/%Y %H:%M"]:
                try:
                    event_date = datetime.datetime.strptime(start_time, fmt)
                    break
                except ValueError:
                    continue
    except Exception as e:
        logging.warning(f"Error parsing event date: {e}")
    
    # Format date and time components
    date_str = event_date.strftime("%Y-%m-%d")
    time_str = event_date.strftime("%H%M")
    
    # Generate a random numeric hash (8 digits)
    random_hash = ''.join(random.choices(string.digits, k=8))
    
    # Extract event type/name if possible (first word of summary)
    event_type = "event"
    if 'summary' in event_details and event_details['summary']:
        # Get first word and convert to lowercase
        first_word = event_details['summary'].split()[0].lower()
        # Remove non-alphanumeric characters and use as event type
        event_type = re.sub(r'[^a-z0-9]', '', first_word)
        if not event_type or len(event_type) < 2:
            event_type = "event"
    
    # Create standardized filename
    new_filename = f"{event_type}_{date_str}_{time_str}_{random_hash}_{platform}.ics"
    
    logging.info(f"Corrected filename: {filename} -> {new_filename}")
    return new_filename


def create_fallback_event(text: str) -> List[Dict]:
    """
    Create a basic calendar event when Claude fails to generate JSON.
    Extracts as much information as possible from the user text.
    
    Args:
        text: User request text
        
    Returns:
        List of dictionaries with platform info for iOS, Android and Outlook
    """
    # Current date and time with +1 day for event
    now = datetime.datetime.now()
    event_date = now + datetime.timedelta(days=1)
    event_date_str = event_date.strftime("%Y-%m-%d")
    
    # Extract time if present (simple pattern matching)
    start_time = "15:00"
    time_patterns = re.findall(r'\d{1,2}[:.]\d{2}', text)  # Match patterns like 15:00 or 3.30
    if time_patterns:
        start_time = time_patterns[0].replace('.', ':')
    
    # Default event duration: 1 hour
    start_datetime = f"{event_date_str} {start_time}"
    end_time = (datetime.datetime.strptime(start_time, "%H:%M") + datetime.timedelta(hours=1)).strftime("%H:%M")
    end_datetime = f"{event_date_str} {end_time}"
    
    # Generate event name
    event_name = "Calendar Event"
    if "встреч" in text.lower():
        event_name = "Meeting"
    elif "звонок" in text.lower() or "созвон" in text.lower():
        event_name = "Call"
    
    # Try to extract location
    location = ""
    office_patterns = re.findall(r'([\w\s,.]+\d+)', text)  # Simple pattern for addresses
    if office_patterns:
        location = office_patterns[0]
    
    # Generate numeric-only hash (no letters)
    random_hash = ''.join(random.choices(string.digits, k=8))
    
    # Create simplified event file info for each platform
    start_date_formatted = event_date.strftime("%Y-%m-%d")
    start_time_formatted = start_time.replace(':', '')
    
    # Base template for all platforms
    base_details = {
        "summary": event_name,
        "start_time": start_datetime,
        "end_time": end_datetime,
        "location": location,
        "description": f"Event created from: {text}"
    }
    
    result = [
        {
            "platform": "ios",
            "filename": f"event_{start_date_formatted}_{start_time_formatted}_{random_hash}_ios.ics",
            "event_details": base_details.copy()
        },
        {
            "platform": "android",
            "filename": f"event_{start_date_formatted}_{start_time_formatted}_{random_hash}_android.ics",
            "event_details": base_details.copy()
        },
        {
            "platform": "outlook",
            "filename": f"event_{start_date_formatted}_{start_time_formatted}_{random_hash}_outlook.ics",
            "event_details": base_details.copy()
        }
    ]
    
    return result


async def generate_calendar_files(request_text: str, conversation=None, user_id=None) -> List[Dict]:
    """
    Generate calendar files (ICS) based on user request and conversation context
    using AI to create both the filename and content.
    
    Args:
        request_text: User request text
        conversation: Conversation history (includes forwarded messages and dialog history)
        
    Returns:
        List of dictionaries with filename and file content for each platform
    """
    
    # Prompt for Claude to generate calendar event details and filenames
    system_prompt = (
        "Вы помощник по созданию календарных событий с вниманием к деталям. Ваша задача - создать информативное и полное описание события календаря в формате JSON."
        ""
        "## ВНИМАНИЕ! КРИТИЧЕСКИ ВАЖНЫЕ ТРЕБОВАНИЯ:"
        "1. Используйте ТОЛЬКО РУССКИЙ ЯЗЫК для названия события, описания и всех текстовых полей."
        "2. Генерируйте РЕАЛЬНОЕ, КОНКРЕТНОЕ описание события. Никогда не возвращайте шаблонные заполнители вроде '[описание]' или 'Событие без дополнительной информации'."
        "3. Для каждого поля придумайте осмысленное содержание, даже если в запросе пользователя немного деталей."
        "4. Ваш ответ должен быть ТОЛЬКО В ФОРМАТЕ JSON - без пояснений, комментариев, блоков кода и т.д."
        "5. Даже если для какого-то поля в запросе нет информации, предоставьте разумное значение, основанное на контексте."
        ""
        "## ФОРМАТ ВЫВОДА:"
        "Ваш ответ должен строго соответствовать этой структуре и не содержать ничего кроме JSON массива с тремя элементами:"
        "["
        "  {"
        "    \"platform\": \"ios\","
        "    \"filename\": \"деловая_встреча_2025-05-21_1400_12345678_ios.ics\","
        "    \"event_details\": {"
        "      \"summary\": \"Деловая встреча с партнерами\","
        "      \"start_time\": \"2025-05-21 14:00\","
        "      \"end_time\": \"2025-05-21 15:30\","
        "      \"location\": \"Бизнес-центр Атриум, Москва, ул. Земляной Вал, 33\","
        "      \"description\": \"Обсуждение квартальных результатов и планов по развитию совместного проекта. Подготовить презентацию и финансовый отчет. Контактное лицо: Андрей Петров, тел. +7 (999) 123-45-67\""
        "    }"
        "  },"
        "  {"
        "    \"platform\": \"android\","
        "    \"filename\": \"деловая_встреча_2025-05-21_1400_12345678_android.ics\","
        "    \"event_details\": {"
        "      \"summary\": \"Деловая встреча с партнерами\","
        "      \"start_time\": \"2025-05-21 14:00\","
        "      \"end_time\": \"2025-05-21 15:30\","
        "      \"location\": \"Бизнес-центр Атриум, Москва, ул. Земляной Вал, 33\","
        "      \"description\": \"Обсуждение квартальных результатов и планов по развитию совместного проекта. Подготовить презентацию и финансовый отчет. Контактное лицо: Андрей Петров, тел. +7 (999) 123-45-67\""
        "    }"
        "  },"
        "  {"
        "    \"platform\": \"outlook\","
        "    \"filename\": \"деловая_встреча_2025-05-21_1400_12345678_outlook.ics\","
        "    \"event_details\": {"
        "      \"summary\": \"Деловая встреча с партнерами\","
        "      \"start_time\": \"2025-05-21 14:00\","
        "      \"end_time\": \"2025-05-21 15:30\","
        "      \"location\": \"Бизнес-центр Атриум, Москва, ул. Земляной Вал, 33\","
        "      \"description\": \"Обсуждение квартальных результатов и планов по развитию совместного проекта. Подготовить презентацию и финансовый отчет. Контактное лицо: Андрей Петров, тел. +7 (999) 123-45-67\""
        "    }"
        "  }"
        "]"
        ""
        "## ВАЖНЫЕ ПРАВИЛА:"
        "1. Для имени файла используйте ТОЛЬКО латинские буквы в нижнем регистре, цифры и подчеркивания."
        "2. Хеш в имени файла должен содержать ТОЛЬКО ЦИФРЫ (8 случайных цифр)."
        "3. Имя файла должно включать тип события, дату, время начала, хеш и платформу."
        "4. Описание события должно содержать не менее 100 символов с полезной информацией."
        "5. Если указано время начала, но не указано время окончания, используйте +1 час от времени начала."
        "6. Используйте текущую дату и время, если они не указаны в запросе пользователя."
        "7. Тщательно проанализируйте весь предоставленный контекст для извлечения информации."
        ""
        "## ПРИМЕР ХОРОШЕГО ОПИСАНИЯ СОБЫТИЯ (если у вас мало информации):"
        "\"Рабочая встреча в офисе компании. Повестка дня: обсуждение текущих задач, распределение обязанностей, планирование на следующую неделю. Не забудьте взять с собой ноутбук и подготовленные материалы. При возникновении вопросов обратитесь к руководителю отдела. После встречи запланирован неформальный кофе-брейк для общения с коллегами.\""
    )
    
    # Combine request and context
    user_prompt = request_text
    if conversation:
        user_prompt = f"Conversation context:\n{conversation}\n\nUser request: {request_text}"
        
    try:
        # Use Claude to generate calendar file information
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
        # Get Claude utilities for API access
        from claude_utils import get_claude_completion
        
        # Use the user_id passed as a parameter
        # This ensures we maintain the correct conversation context
        current_user_id = user_id
        
        # Log information about user identification
        if current_user_id:
            logging.info(f"Using provided user_id={current_user_id} for calendar generation")
        else:
            logging.warning("No user_id provided for calendar generation, context might be lost")
        
        # Prepare messages with conversation context
        user_message = user_prompt
        
        # If we have conversation history, use it directly as messages for Claude API
        if conversation and isinstance(conversation, list) and all(isinstance(msg, dict) for msg in conversation):
            # We'll directly use the conversation history messages in the API call
            # First, log some information about the history
            message_count = len(conversation)
            user_messages = len([m for m in conversation if m.get('role') == 'user'])
            assistant_messages = len([m for m in conversation if m.get('role') == 'assistant'])
            
            logging.info(f"Using conversation history with {message_count} messages total: {user_messages} user, {assistant_messages} assistant")
            
            # For a detailed log entry, sample the most recent messages
            if message_count > 0 and 'content' in conversation[-1]:
                recent_content = conversation[-1]['content'][:100] + '...' if len(conversation[-1]['content']) > 100 else conversation[-1]['content']
                logging.info(f"Most recent message: [{conversation[-1].get('role', 'unknown')}] {recent_content}")
                
            # Add the current request as a new user message
            user_message = request_text
        else:
            # Fallback for unexpected conversation format - convert to string
            formatted_conversation = ""
            if conversation:
                if isinstance(conversation, list):
                    for item in conversation:
                        formatted_conversation += str(item) + "\n"
                else:
                    formatted_conversation = str(conversation)
                
                # Format as a single message with context
                user_message = f"Conversation context:\n{formatted_conversation}\n\nRequest: {request_text}\n\nPlease generate calendar event details based on the conversation above."
                logging.info(f"Using fallback string format for conversation context")
            else:
                # No conversation history
                user_message = request_text
                logging.info("No conversation history provided for calendar generation")
        
        # Format messages for Claude API
        final_messages = []
        
        # First add the system prompt for this specific request
        if system_prompt:
            final_messages.append({"role": "system", "content": system_prompt})
            
        # If we have a proper conversation history format, use it directly
        if conversation and isinstance(conversation, list) and all(isinstance(msg, dict) for msg in conversation):
            # Make a copy of conversation history to avoid modifying the original
            existing_messages = conversation.copy()
            
            # Add the current request as the latest user message
            final_messages.extend(existing_messages)
            final_messages.append({"role": "user", "content": request_text})
            
            logging.info(f"Using existing conversation history with {len(existing_messages)} messages")
        else:
            # Simple approach with just our formatted user message
            final_messages.append({"role": "user", "content": user_message})
            logging.info("Using single message approach without history")
        
        # Log the final message count
        logging.info(f"Final message count for Claude API: {len(final_messages)}")
        
        try:
            # Import Claude API functions
            from claude_utils import get_claude_completion
            
            # Make a technical request that doesn't save to conversation history
            completion = await get_claude_completion(
                messages=final_messages,
                max_tokens=4000, 
                temperature=0.2, 
                user_id=current_user_id,
                save_in_history=False   # Don't save this technical request
            )
            
            logging.info(f"Received calendar generation response (length: {len(completion)}, first 100 chars): {completion[:100]}...")
        except Exception as e:
            logging.error(f"Error in Claude API call for calendar: {str(e)}")
            # Create a basic fallback in case of API error
            completion = ""
            raise e
        
        # Log the full response for debugging
        logging.info(f"Attempting to parse JSON from Claude response")
        
        # Try multiple regex patterns to find JSON array in the response
        json_patterns = [
            r'\[\s*\{[\s\S]*?\}\s*\]',    # Standard JSON array
            r'```json\s*\[(.*?)\]\s*```',   # JSON in code block
            r'```\s*\[(.*?)\]\s*```'       # JSON in generic code block
        ]
        
        json_str = None
        for pattern in json_patterns:
            json_match = re.search(pattern, completion, re.DOTALL)
            if json_match:
                json_str = json_match.group(0)
                # Clean up if it was in a code block
                if '```' in json_str:
                    json_str = re.sub(r'```(?:json)?\s*', '', json_str)
                    json_str = re.sub(r'\s*```', '', json_str)
                logging.info(f"Found JSON using pattern: {pattern[:20]}...")
                logging.info(f"Extracted JSON (first 100 chars): {json_str[:100]}...")
                break
        
        if json_str:
            try:
                platform_files = json.loads(json_str)
                logging.info(f"Successfully parsed JSON into {len(platform_files)} platform entries")
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding JSON from Claude response: {e}")
                logging.error(f"Problematic JSON string: {json_str[:200]}...")
                # Fallback to creating a basic event if JSON parsing fails
                platform_files = create_fallback_event(user_prompt)
        else:
            logging.error(f"No JSON found in Claude response after trying all patterns")
            # For debugging, show more of the response
            logging.error(f"Response fragment: {completion[:200]}...")
            # Fallback to creating a basic event if no JSON is found
            platform_files = create_fallback_event(user_prompt)
        
        # Create calendar files for each platform
        result_files = []
        
        for platform_info in platform_files:
            platform = platform_info.get('platform')
            filename = platform_info.get('filename')
            event_details = platform_info.get('event_details')
            
            if not all([platform, filename, event_details]):
                continue
            
            # Проверяем и корректируем имя файла, чтобы использовать текущую дату и уникальный хеш
            filename = ensure_valid_calendar_filename(filename, event_details, platform)
            
            # Create ICS file with detailed logging
            try:
                logging.info(f"Creating ICS file for {platform} with event details: {json.dumps(event_details, ensure_ascii=False)[:100]}...")
                ics_content = create_ics_file(event_details)
                
                # Verify that we actually got binary content
                if ics_content and isinstance(ics_content, bytes) and len(ics_content) > 10:
                    logging.info(f"Successfully created ICS content for {platform}, {len(ics_content)} bytes")
                else:
                    # Something went wrong, log the issue
                    logging.error(f"Failed to create valid ICS content for {platform}: "
                                f"{'Empty content' if not ics_content else 'Invalid type: ' + str(type(ics_content)) if not isinstance(ics_content, bytes) else 'Content too small: ' + str(len(ics_content)) + ' bytes'}")
                    
                    # Try to create content again with fallback event details
                    logging.info(f"Attempting to create fallback ICS content for {platform}")
                    fallback_details = {
                        "summary": event_details.get('summary', 'Event'),
                        "start_time": event_details.get('start_time', datetime.datetime.now().strftime('%Y-%m-%d %H:%M')),
                        "end_time": event_details.get('end_time', (datetime.datetime.now() + datetime.timedelta(hours=1)).strftime('%Y-%m-%d %H:%M')),
                        "description": event_details.get('description', '')
                    }
                    ics_content = create_ics_file(fallback_details)
                    logging.info(f"Created fallback content: {len(ics_content) if ics_content else 0} bytes")
            except Exception as e:
                logging.error(f"Exception when creating ICS content: {e}")
                # Create minimal valid calendar file as last resort
                cal = Calendar()
                cal.add('prodid', '-//Telegram Bot//Calendar//EN')
                cal.add('version', '2.0')
                event = Event()
                event.add('summary', event_details.get('summary', 'Event'))
                event.add('dtstart', datetime.datetime.now())
                event.add('dtend', datetime.datetime.now() + datetime.timedelta(hours=1))
                event.add('dtstamp', datetime.datetime.now())
                event.add('uid', str(uuid.uuid4()))
                cal.add_component(event)
                ics_content = cal.to_ical()
                logging.info(f"Created emergency fallback ICS content: {len(ics_content)} bytes")
            
            # Add file info to results with binary content verification
            if ics_content and isinstance(ics_content, bytes) and len(ics_content) > 10:
                result_files.append({
                    'filename': filename,
                    'content': ics_content,  # Guaranteed to be valid binary content
                    'event_details': event_details,  # Сохраняем детали события
                    'platform': platform,           # Сохраняем платформу
                    'description': f"Calendar event: {event_details.get('summary')} ({platform.upper()})"
                })
                logging.info(f"Added {platform} file to results with {len(ics_content)} bytes of content")
            else:
                logging.error(f"Failed to add {platform} file to results: invalid content")
        
        if result_files:
            return result_files
        else:
            logging.error("No valid platform files created")
            
    except json.JSONDecodeError as e:
        logging.error(f"Error parsing JSON from Claude response: {e}")
        traceback.print_exc()
    except Exception as e:
        logging.error(f"Error generating calendar files: {str(e)}")
        traceback.print_exc()
        
    # Return empty list in case of error
    return []


def create_ics_file(event_details: Dict[str, Any]) -> bytes:
    """
    Create an ICS (iCalendar) file from event details
    
    Args:
        event_details: Dictionary with event details
        
    Returns:
        ICS file content as bytes
    """
    # Ensure correct language encoding by setting the language parameter
    # Filename will be in English but content inside will be in Russian
    # Create calendar
    cal = Calendar()
    
    # Add standard calendar properties
    cal.add('prodid', '-//Telegram Bot//Calendar//EN')
    cal.add('version', '2.0')
    cal.add('calscale', 'GREGORIAN')
    cal.add('method', 'PUBLISH')
    
    # Create event
    event = Event()
    
    # Add unique identifier
    event.add('uid', str(uuid.uuid4()))
    
    # Add creation time
    event.add('dtstamp', datetime.datetime.now())
    
    # Add event title
    summary = event_details.get('summary', 'Событие')
    event.add('summary', summary)
    
    # Process start time
    try:
        start_time_str = event_details.get('start_time', datetime.datetime.now().strftime("%Y-%m-%d %H:%M"))
        
        # Support various date/time formats
        try:
            # First try standard format
            start_time = datetime.datetime.strptime(start_time_str, "%Y-%m-%d %H:%M")
        except ValueError:
            # Try alternative formats
            try:
                start_time = datetime.datetime.strptime(start_time_str, "%d.%m.%Y %H:%M")
            except ValueError:
                try:
                    start_time = datetime.datetime.strptime(start_time_str, "%m/%d/%Y %H:%M")
                except ValueError:
                    # If nothing works, use current time
                    start_time = datetime.datetime.now()
                    logging.warning(f"Could not parse start time: {start_time_str}, using current time")
        
        # Set Moscow time by default if no timezone specified
        moscow_tz = pytz.timezone('Europe/Moscow')
        if start_time.tzinfo is None:
            start_time = moscow_tz.localize(start_time)
            
        event.add('dtstart', start_time)
    except Exception as e:
        logging.error(f"Error setting start time: {str(e)}")
        # Use current time as fallback
        start_time = datetime.datetime.now(pytz.timezone('Europe/Moscow'))
        event.add('dtstart', start_time)
    
    # Process end time
    try:
        end_time_str = event_details.get('end_time')
        if end_time_str:
            # Same format checks as for start_time
            try:
                end_time = datetime.datetime.strptime(end_time_str, "%Y-%m-%d %H:%M")
            except ValueError:
                try:
                    end_time = datetime.datetime.strptime(end_time_str, "%d.%m.%Y %H:%M")
                except ValueError:
                    try:
                        end_time = datetime.datetime.strptime(end_time_str, "%m/%d/%Y %H:%M")
                    except ValueError:
                        # If we can't parse end time, add 1 hour to start time
                        end_time = start_time + datetime.timedelta(hours=1)
                        logging.warning(f"Could not parse end time: {end_time_str}, using start_time + 1 hour")
        else:
            # If end time not specified, add 1 hour to start time
            end_time = start_time + datetime.timedelta(hours=1)
        
        # Ensure end_time has the same timezone as start_time
        if end_time.tzinfo is None and start_time.tzinfo is not None:
            moscow_tz = pytz.timezone('Europe/Moscow')
            end_time = moscow_tz.localize(end_time)
        
        event.add('dtend', end_time)
    except Exception as e:
        logging.error(f"Error setting end time: {str(e)}")
        # Use start time + 1 hour as fallback
        event.add('dtend', start_time + datetime.timedelta(hours=1))
    
    # Add location if specified
    location = event_details.get('location')
    if location:
        event.add('location', location)
    
    # Add description if specified
    description = event_details.get('description')
    if description:
        event.add('description', description)
    
    # Add reminder 15 minutes before
    try:
        from icalendar import Alarm
        # Create alarm object
        alarm = Alarm()
        alarm.add('action', 'DISPLAY')
        # Use Russian for alarm description
        alarm.add('description', f"Напоминание: {summary}")
        # Set trigger time (15 minutes before start)
        alarm.add('trigger', datetime.timedelta(minutes=-15))
        event.add_component(alarm)
    except Exception as e:
        logging.error(f"Error adding alarm: {str(e)}")
    
    # Add event to calendar
    cal.add_component(event)
    
    # Generate file content with verification
    try:
        content = cal.to_ical()
        
        # Verify content is correctly created
        if not content or not isinstance(content, bytes) or len(content) < 10:
            logging.error(f"Invalid ics content generated: "
                         f"{'Empty' if not content else 'Wrong type: ' + str(type(content)) if not isinstance(content, bytes) else 'Too small: ' + str(len(content)) + ' bytes'}")
            
            # Last resort: create minimal valid ICS content
            min_cal = Calendar()
            min_cal.add('prodid', '-//Telegram Bot//Calendar//EN')
            min_cal.add('version', '2.0')
            min_event = Event()
            # Make sure to add basic required components
            min_event.add('summary', 'Event')
            min_event.add('dtstart', datetime.datetime.now())
            min_event.add('dtend', datetime.datetime.now() + datetime.timedelta(hours=1))
            min_event.add('dtstamp', datetime.datetime.now())
            min_event.add('uid', str(uuid.uuid4()))
            min_cal.add_component(min_event)
            content = min_cal.to_ical()
            logging.info(f"Created basic emergency ICS content: {len(content)} bytes")
        else:
            logging.info(f"Successfully generated valid ICS content: {len(content)} bytes")
            
        return content
    except Exception as e:
        logging.error(f"Exception in create_ics_file: {e}")
        # Create absolute minimum valid calendar in case of any error
        emergency_cal = Calendar()
        emergency_cal.add('prodid', '-//Telegram Bot//Calendar//EN')
        emergency_cal.add('version', '2.0')
        emergency_event = Event()
        emergency_event.add('summary', 'Emergency Event')
        emergency_event.add('dtstart', datetime.datetime.now())
        emergency_event.add('dtend', datetime.datetime.now() + datetime.timedelta(hours=1))
        emergency_event.add('dtstamp', datetime.datetime.now())
        emergency_event.add('uid', str(uuid.uuid4()))
        emergency_cal.add_component(emergency_event)
        emergency_content = emergency_cal.to_ical()
        logging.info(f"Created emergency ICS content due to exception: {len(emergency_content)} bytes")
        return emergency_content
